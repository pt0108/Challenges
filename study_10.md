> 2023년 2월 3

이번에 알아볼 알고리즘은 다이나믹 프로그래밍이다.

***Dynamic Programing, 동적계획법***이라고도 하는 이 알고리즘은, 

한 번 결과가 수행된 것은 메모리에 저장해두고, 다음에 같은 결과가 필요하면 다시 연산하지 않고 메모리에 저장된 값을 불러오는 것이다. (**계산 값을 저장해두었다가 재사용)**

이 알고리즘은 연속되지 않은 자료가 주어질 때 유용하다고 한다!

→ [Dynamic Programing](https://techblog-history-younghunjo1.tistory.com/183)

그리고 이 [링크](https://doing7.tistory.com/75)를 통해 더 자세히 개념을 알아보면 좋을 것 같다. 정말 정리가 잘 되어있다.

**피보나치 수열**이 바로 다이나믹 프로그래밍으로 해결할 수 있는 가장 대표적인 예라고 한다.

피보나치 수열은 **현재 항을 계산하기 위해 이전 두 항의 합을 구해야**한다.

- 피보나치 수열 점화식(재귀함수)
    
    ```python
    def fibo(x):
    	if x==1 or x==2:
        	return 1
        return fibo(x-1) + fibo(x-2)
        
    print(fibo(5))
    ```
    

이 코드의 문제점은, 값이 증가할 때마다 연산하는데 걸리는 시간이 기하급수적으로 늘어난다는 것! ← 동일한 함수가 반복적으로 호출되기 때문

이 문제를 해결하기 위해 다이나믹 프로그래밍을 사용하는 것이다.

### ****Topdown(하향식)****

큰 문제를 해결하기 위해 작은 문제를 호출하며, 재귀함수로 구현할 수 있다.

```python
# 한번 계산된 결과를 memoiztion하기 위한 리스트
memo = [0]*100

# 피보나치 수열을 재귀함수로 구현(topdown)
def fibo(x):
  # fibo(1)=fibo(2)=0
  if x==1 or x==2:
    return 1

  # 이미 계산한 적있는 문제라면 그대로 반환
  if memo[x] != 0:
    return memo[x]

  # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
  memo[x] = fibo(x-1)+fibo(x-2)
  return memo[x]

print(fibo(99))
```

### ****Bottom-Up 상향식****

위 문제부터 시작해서 더 큰 문제를 해결해 나가며, 반복문으로 구현할 수 있다.

```python
# 작은 문제부터 해결해서 저장할 dp 리스트
dp = [0]*100

# fibo(1)=fibo(2)=0
dp[1]=1
dp[2]=1
n=99

# 피보나치 수열을 반복문으로 구현(bottom up)
for i in range(3, n+1):
  dp[i] = dp[i-1]+dp[i-2]

print(dp[n])
```

---

## 9095 [1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

### 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

### 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

**예제 입력1**

**예제 출력1**

```python
3
4
7
10
```

```python
7
44
274

```

3 (테스트 케이스 개수)

4 → 7

7 → 44

10 → 274

이제 n을 1, 2, 3의 합으로만 나타내는 방법을 어떻게 구하면 좋을지 생각해야겠다.

… 그러나 어떤 구조로 작동되는 것인지 전혀 떠오르지 않아 풀이를 찾아보았다.

---

이 문제는 **동일한 문제가 작은 수에 대해 반복적인 것**을 알 수 있다. 그래서 상향식으로 작은 수부터 해답을 찾아가면 문제를 풀 수 있다고 한다.

정수 n을 1, 2, 3의 합으로 표현할 수 있는 방법을 생각해보면, 아래와 같다.

- `n-3` 에 3을 더하는 경우
- `n-2` 에 2를 더하는 경우
- `n-1` 에 1을 더하는 경우

합으로 나타내는 경우의 수 `count(n)`은 맨 앞에 각각 1, 2, 3을 놓았을 때, 나머지 부분의 경우의 수들의 합이라고 할 수 있다. 맨 앞이 1일 경우, n에서 1을 뺀 나머지의 경우의 수이므로 `count(n-1)`이고, 나머지 수에 대해서는 각각 `count(n-2)`, `count(n-3)`이 된다.

→ `count(n) = count(n-1) + count(n-2) + count(n-3) , n > 3`

여기서 n이 3보다 작거나 같은 경우(1, 2, 3)는 `count(1)=1, count(2)=2, count(3)=4` 로 구할 수 있다.

`count(3)=4` 인 이유가 뭘까 고민했는데, 1+1+1, 1+2, 2+1, 3 총 4가지이기 때문 아닐까? 싶다.

[풀이1](https://devvvyang.tistory.com/17)

```python
# 테스트 케이스 입력받기
T = int(input())

# 입력받은 테스트 케이스 수 만큼 반복
for _ in range(T):

    n = int(input())
	
    # DP 테이블 초기화
    d = [0] * 12  # n이 최대 11미만이기 때문에

    d[1] = 1
    d[2] = 2
    d[3] = 4
	
 	# 상향식으로 구현
    for i in range(4, 12):
        d[i] = d[i - 1] + d[i - 2] + d[i - 3]

    print(d[n])
```

[풀이2](https://jamesu.dev/posts/2020/01/07/baekjoon-problem-solving-9095/)

```python
ns = [int(input()) for _ in range(int(input()))]

counts = {1: 1, 2: 2, 3: 4}
def count(i):
  if i in counts:
    return counts[i]
  counts[i] = count(i - 1) + count(i - 2) + count(i - 3)
  return counts[i]

for n in ns:
  print(count(n))
```
