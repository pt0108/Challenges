> 2022년 11월 5주 ~ 12월 1주

알고리즘 문제를 풀 때,

가장 중요한 것은 문제를 이해하는 것.

1. 문제의 목표를 찾는다.
2. 요구사항을 정확히 파악한다.
3. 풀이 과정에서 요구사항을 기반으로 순서도를 짜고 생각한다.
4. 결과를 도출한다.


**11/29**

- [**폰켓몬](https://school.programmers.co.kr/learn/courses/30/lessons/1845)**
    
    
    **<문제의 조건>**
    
    - 총 N마리의 포켓몬 중에서 N/2(절반)마리를 가져가도 좋음
    - 폰켓몬은 종류에 따라 번호를 붙여 구분
    
    **<예문에서 알 수 있는 것>**
    
    - 종류가 같은 폰켓몬을 뽑는 예시
    - 종류가 다른 폰켓몬을 뽑는 예시
    
    **<입력값>**
    
    N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어짐
    
    **<출력해야 할 결과값>**
    
    N/2마리의 폰켓몬을 선택하는 방법 중,
    
    **가장 많은 종류의 폰켓몬을 선택하는 방법**을 찾아서
    
    그때의 **폰켓몬 종류 번호의 개수를 return**
    
    *(종류가 중복되지 않은 폰켓몬의 수를 구해야 하는 것.)*
    
    tip : 계산값과 N/2의 값을 비교해 더 작은 값이 결과(최대 종류수)가 된다!
    
    1. 입력된 배열을 오름차순으로 정렬한다.
    2. 배열의 유니크한 값(중복되지 않는 값)을 for문을 통해서 카운트한다.
        
        카운트값 = 중복되지 않는 폰켓몬을 뽑을 수 있는 머릿수
        
    3. if count값 > N/2 → return N/2
        
        else → return count 값
        
        어차피 뽑을 수 있는 최대값이 N/2로 한정되어 있기 때문에,
        
        count 값이 N/2를 넘어가도 N/2만큼 뽑을 수밖에 없다!
        
    
    ```python
    def solution(nums):
        # 입력된 배열을 정렬
        nums.sort()
        
    		# 카운트를 세기 위한 그릇 준비
        n_list = []
        count = 0
        
        # 배열에 들어있는 고유한 값을 count하기
        for n in nums:
            if n not in n_list: # 빈 리스트 안에 처음 들어가는 수가 있으면 count += 1 후 append
                count += 1
                n_list.append(n)
            else: # n이 이미 리스트에 들어있으면 건너뛴다
                continue
        if count > len(nums)/2: # N/2가 count보다 크면 N/2 반환
            return int(len(nums)/2)
        else:
            return count # N/2가 count보다 작으면 count 반환
    ```
    
    다른 사람의 풀이를 봤더니,
    
    중복된 값을 제거해주는 **set()**을 사용하는 풀이도 있었다. 
    
    참고하면 좋을 것 같다.
    

- [**2016년**](https://school.programmers.co.kr/learn/courses/30/lessons/12901)
    
    
    **<문제의 조건>**
    
    - 두 수 a, b를 입력받아 2016년 a월 b일이 무슨 요일인지 return
    - 2016년 1월 1일은 금요일
    
    → 입력된 날짜의 요일을 구하는 문제여서, 
    
        **datetime의 weekday()함수**를 검색, 사용해보았다.
    
    ```python
    from datetime import date
    
    def solution(a, b):
        days = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
        return days[date(2016,a,b).weekday()]
    ```
    
    → **weekday()** 함수는 **월요일부터 일요일까지 0~6의 정수로 반환**해주기 때문에,
    
        days 리스트의 인덱스로 사용함!
    
    다만, 함수를 사용해서 문제는 성공적으로 풀었지만
    
    실력 향상 겸 테스트 대비 공부이기 때문에 외부 모듈 사용은 지양하는 쪽으로!
    

**12/01**

- **[햄버거 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/133502)**
    
    
    **<문제의 조건>**
    
    - 상수의 가게는 정해진 순서(아래서부터, 빵 - 야채 - 고기 - 빵)로 쌓인 햄버거만 포장
    - 재료의 정보를 나타내는 정수 배열이 주어졌을 때, 상수가 포장하는 햄버거의 개수를 리턴
    
    → 문제를 자세히 보면, 배열에 [1, 2, 3, 1] 순으로 원소가 있어야 햄버거 1개를 포장할 수 있음을 알 수 있다. 맨 처음에는 배열을 아예 문자열로 join해버리고 “1231”을 문자열에서 삭제할 때마다 1회씩 카운트를 더하면 될까? 하는 생각으로 코드를 작성해봤는데, 시간 초과로 실패했다.
    
    → 문자열로 번거롭게 바꾸고, 업데이트하지 말고 인덱스 슬라이싱으로 생각을 전환해보자. 입력된 재료들을 그대로 빈 리스트에 하나씩 쌓아보는 것이다. **재료를 쌓은 리스트의 [-4:] 로 슬라이싱해서 [1, 2, 3, 1]과 같은지 비교**해보는 것이다. 비교를 해서 [1, 2, 3, 1]과 **같으면 1회씩 카운트를 더하고, 리스트에 쌓인 (포장 조건이 충족된) [1, 2, 3, 1]을 삭제**하는 방식으로 코드를 작성했다. 
    
    ```python
    def solution(ingredient):
        count = 0
        emp = []
        
        # 빈 리스트에 원소를 하나씩 쌓으면서 그 리스트의[-4:]가 1, 2, 3, 1 이 되면 삭제하고 count
        for i in ingredient:
            emp.append(i)
            if emp[-4:] == [1, 2, 3, 1]:
                del emp[-4:]
                count += 1
        return count
    ```
    
    완성된 코드가 이것.
    
    처음에 `emp.append(i)` 를 if 문 안에 넣는 실수를 해서,
    
    햄버거 포장이 끝까지 되지 않는 오류가 생겼었다. 
    
    재료 i 를 빈 리스트에 append하는 것은 if 문과 상관없기 때문에 if 문의 바깥에 작성을 해야 코드가 정상적으로 작동한다.
